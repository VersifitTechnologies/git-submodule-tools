#!/bin/bash -e
## Do a recursive push
## accepts the same argumenta as push

## read input, display help if necessary
if [[ "$@" == *--help* ]]; then
    cat<<EOF
 Recursive push

 This command executes git-cpush recursively. It starts with
 the innermost submodules and then works its way back. Only accepts
 two levels of submodules. The push is only executed if all 
 submodules are on remote-tracking branches.

 Usage:
    git rpush ...

    ...: same arguments as git-push
EOF
    exit 0;
fi

## check for modified content and uncommitted changes
git check-clean --ignore-submodules=untracked --unstaged --uncommitted --unmerged || exit 1
## check for untracked files
git check-clean --untracked --unstaged --exit-code || echo "Warning: There are untracked files not in .gitignore."
## check for non remote tracking branches and fail
## TODO: if not --all
git submodule --quiet foreach --recursive "git check-branch" || exit 1
## TODO: check for unpulled changes: fetch, then check
# git fetch -q
# git submodule --quiet foreach --recursive "git fetch -q"


## from http://www.linuxforums.org/forum/programming-scripting/62564-bash-script-problem-preserving-quotes-arguments.html
CMD="git cpush -q"

for (( i = 1; i <= $# ; i++ )); do
  eval ARG=\$$i
  CMD="$CMD $(echo "$ARG" | awk '{gsub(".", "\\\\&");print}')"
done

## !!! check for uncommitted changes ???
## push second level repositories
echo "Pushing second level submodules..."
git submodule --quiet foreach "git submodule --quiet foreach \"$CMD\"" || exit 1
echo "done."
## push first level repositories
echo "Pushing first level submodules..."
git submodule --quiet foreach git cpush -q "$@" || exit 1
echo "done."
## push super rep.
git cpush -q "$@"
