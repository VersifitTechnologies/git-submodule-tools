#!/bin/bash -e
## Conditional commit
## commit only if there is something to commit
## and warn if there are files that are neither added
## nor ignored.

## read input, display help if necessary
if [[ "$@" == "" || "$@" == *--help* ]]; then
    cat<<EOF
 This command is very similar to git-commit. The only difference is
 that a new commit is only recorded, if the resulting commit is not
 empty. (Thus avoiding the error that would be raised by git-commit.)
 Gives a warning if there are unstaged changes.

 Usage:
    git ccommit ...

    ...: same arguments as git-commit
EOF
    exit 0;
fi

a=0
q=0

## ToDo: what about --all???
while getopts ":aq" opt; do
    case $opt in
	a)
	    a=1
	    #echo "-a was triggered!" >&2
	    ;;
	q)
	    q=1
	    #echo "-q was triggered!" >&2
	    ;;
	\?)
	    # ignore this
	    #echo "Invalid option: -$OPTARG" >&2
	    ;;
  esac
done

if [ $a -ne 1 ] && ! git check-clean --unstaged --unmerged --exit-code --ignore-submodules=dirty; then
    echo "Warning in $PWD:"
    echo " Unstaged changes to files under version control."
    echo " To add, use option -a to stage or add files manually with git add <file>."
fi 
    
## commit if dirty (or --allow-empty is given)
if [[ "$@" == *--allow-empty* ]] || ([ $a -eq 1 ] && ! git check-clean --unstaged --unmerged --exit-code --ignore-submodules=dirty) || ! git check-clean --uncommitted --exit-code --ignore-submodules=dirty; 
then
    ## check for detached head
    if [[ $(cat .git/HEAD | cut -c1-4) != "ref:" ]]; then
	echo "Error in $PWD:"
	echo " Refused to commit in detached head state. Use \"git rcheckout <branchname>\" to attach HEAD. List branches with \"git branch -v\"."
	exit 1
    fi

    echo "Commiting in $PWD..."
    git commit "$@"
    
    if [ -f .gitmodules ]; then
	## Syncronize submodules if necessary
	git converge-submodules -q
    fi
else
    if [ $q -ne 1 ]; then
	echo "Directory clean, skipping"
    fi
fi
