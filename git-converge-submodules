#!/bin/bash -e
## If local and remote have diverged, but actually
## only the submodule pointers are different 
## force a rebase to syncronise them again.
## -q for quiet operation
## -f for forcing trying to converge

while getopts ":fq" opt; do
    case $opt in
	q)
	    q=1
	    #echo "-q was triggered!" >&2
	    ;;
	f)
	    force=1
	    #echo "-f was triggered!" >&2
	    ;;
	\?)
	    # ignore this
	    #echo "Invalid option: -$OPTARG" >&2
	    ;;
  esac
done 

if [ -f .gitmodules ]; then
    ## Check if local and remote have diverged
    ## in the submodules and rebase if necessary
    ## check if its a remote tracking branch and get it
    tmp=`git branch --no-color -vv 2> /dev/null`
    while read line; do
	if [[ "${line:0:1}" != "*" ]]; then
	    continue
	fi
	##echo "$line"
	branch=`expr "$line" : '\** *\([^ ]*\)'`
	remote=`expr "$line" : '.*\[\(.*\)\]'` || nontracking=0
	remote=`expr "$remote" : '\([^:]*\)'`
    done <<< "$tmp"
    
    if [[ ! "$nontracking" ]]; then
	## get submodules
	tmp=`git config -f .gitmodules --get-regexp "submodule\..*\.path"`
	while read line; do
	    sub="$sub ${line#submodule.*.path }"
	done <<< "$tmp"
	## echo "$sub"
	# output=`git diff $branch...$remote --stat --no-ext-diff $sub`
	# if [[ "$output" ]]; then
	#     echo "Converge started..."
	#     echo "$output"
	# fi
	if [[ $force -eq 1 ]] || ! git diff $branch...$remote --no-ext-diff --quiet --exit-code $sub; then
	    ## there are differences, do a rebase
            ## check for uncommmited changes first
	    if ! git diff --no-ext-diff --quiet --exit-code; then
		echo "Error in $PWD:"
		echo " Uncommited changes, cannot converge branches"
		exit 1
	    fi
	    echo "Converging local and remote..."
	    ## check for differences other than in submodule pointers
	    output=`git diff $branch...$remote --no-ext-diff --stat --ignore-submodules`
	    if [[ "$output" != "" ]]; then
		## ok, there may be just differences in .gitmodules
		if [[ $(echo "$output" | sed -e '$ d' -e '/ .gitmodules/ d') == "" ]]; then
		    ## so probably a submodule was removed in the remote
		    ## and we made some changes to it
		    ## the next section has some overlap with
		    ## git-rm-submodule and git-rm-orphaned-submodules
		    ## make sure they're clean
		    git submodule --quiet foreach git check-clean
		    ## check for unpushed changes in submodules
		    git submodule --quiet foreach git check-unpushed
		    ## check for local non-tracking branches
		    git submodule --quiet foreach git check-non-tracking
		    ## pull, make checks later
		    ## take their version, but create a backup of ours
		    cp .gitmodules .gitmodules~
		    git pull -q -s recursive -X theirs >/dev/null 2>&1 || echo "Removing submodules dropped in remote..."
		    ## then start removing submodules
		    tmp=`git status --porcelain`
		    while read line; do
			if [[ "${line:0:2}" == "UD" || "${line:0:2}" == "??" ]]; then
			    ## this has to be removed
			    lsub=${line:3}
			    if [[ $q -ne 1 ]]; then
				url=`git config -f .gitmodules~ --get submodule.$lsub.url` && echo "Removing submodule \"$lsub\"." && echo "Issue \"git submodule add $url $lsub\" to add again."
			    fi
			    rm -r "$lsub/"
			    git rm --ignore-unmatch --quiet "$lsub" >/dev/null
			fi
		    done <<< "$tmp"
		    rm .gitmodules~
		    git ccommit -qm 'Converged submodules'
		else
		    echo "Error in $PWD: (got cold feet)"
		    echo " Differences between local and remote other than just submodules, cannot converge branches. Rebase by hand."
		    exit 1
		fi
	    else
		git pull
	    fi
	    echo "done."
	else 
	    if [[ $q -ne 1 ]] && ! git diff $branch..$remote --no-ext-diff --quiet --exit-code $sub; then
		echo "Notice in $PWD:"
		echo " Not converging, use \"git converge-submodules -f\" if necessary"
	    fi
	fi  
    fi
fi