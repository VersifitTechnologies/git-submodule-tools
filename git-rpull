#!/bin/bash -e
## Do a recursive pull
## check for unclean folders
## and unpushed changes, since this might cause trouble
## if there are such changes, you have to do it by hand
## e.g., merge the where there are local and remote changes

## read input, display help if necessary
if [[ "$@" == *--help* ]]; then
    cat<<EOF
 Recursive pull

 This command executes a git-pull and then updates all submodules.
 Orphaned submodule directories are removed if they are clean. The
 HEADs of submodules are attached if necessary and possible. 
 Executes git-rfetch to download possibly existing updates for
 submodules.

 Usage:
    git rpull
EOF
    exit 0;
fi

## check for modified content and uncommitted changes
git check-clean --ignore-submodules=untracked --unstaged --uncommitted --unmerged || exit 1
## check for untracked files
if [[ $(git check-clean --untracked --unstaged --exit-code || echo "FAIL") == "FAIL" ]]; then
    cat<<EOF
 Error: Untracked files in submodules. Add them to .gitignore
  in the respective submodules or remove them.
  Use "git status" to see where they are.
EOF
    exit 1
fi

## check for unpushed commits in submodules
if [ -f .gitmodules ]; then
    unpushed=`git submodule --quiet foreach --recursive git check-unpushed -p`
    if [[ "$unpushed" != "" ]]; then
	cat<<EOF 
 Error: Unpushed commits in submodules.
  $unpushed
  Push them one-by-one before pulling again. Otherwise some
  commits might get lost.
EOF
	exit 1
    fi
fi
## git check-unpushed # no need to check in master

## do the pull
## git pull --recurse-submodules (does not work)
git pull || exit 1

if [ -f .gitmodules ]; then
    ## fix submodules
    git fix-submodules --skip-checks
    ## fetch changes in submodules 
    ## this is necessary since if the submodule commit did not change
    ## in the super rep., then the submodule is not updated.
    ## rfetch does this
    git rfetch
fi
